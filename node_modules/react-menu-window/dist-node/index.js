'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var Portal = require('reakit/Portal');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function useAnimationFrame(update, pause = false, deps = []) {
  const latestAnimationFrame = React.useRef(null);
  React.useEffect(() => {
    if (typeof pause === "function" ? pause() : pause) {
      return;
    }

    latestAnimationFrame.current = requestAnimationFrame(() => {
      update();
    });
    return () => {
      if (latestAnimationFrame.current) {
        cancelAnimationFrame(latestAnimationFrame.current);
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [update, pause, ...deps]);
}

const fitsOnBottom = viewportOffset => (elemRect, viewportRect) => elemRect.bottom < viewportRect.height - viewportOffset;
const fitsOnRight = viewportOffset => (elemRect, viewportRect) => elemRect.right < viewportRect.width - viewportOffset;
const getFitOffsets = viewportOffset => elemRect => {
  const viewportRect = {
    width: window.innerWidth,
    height: window.innerHeight
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (!fitsOnRight(viewportOffset)(elemRect, viewportRect)) {
    offsets.x = viewportRect.width - viewportOffset - elemRect.right;
  }

  if (!fitsOnBottom(viewportOffset)(elemRect, viewportRect)) {
    offsets.y = viewportRect.height - viewportOffset - elemRect.bottom;
  }

  return offsets;
};

const DEFAULT_POSITION = {
  top: 0,
  left: 0
};
function useFitInViewport(elemRef, targetPos, viewportOffset = 0) {
  const [style, setStyle] = React.useState(targetPos);
  React.useEffect(() => {
    setStyle(targetPos);
  }, [targetPos]);
  useAnimationFrame(() => {
    if (!elemRef.current) {
      return;
    }

    const {
      x,
      y
    } = getFitOffsets(viewportOffset)(elemRef.current.getBoundingClientRect());
    setStyle(prevStyle => {
      const nextStyle = {
        top: (prevStyle || DEFAULT_POSITION).top + y,
        left: (prevStyle || DEFAULT_POSITION).left + x
      };
      return nextStyle;
    });
  }, () => !elemRef.current, [style]);
  return {
    style
  };
}

const setEventListeners = (events, fn, elem, set) => {
  events.forEach(event => {
    (set === "add" ? elem.addEventListener : elem.removeEventListener)(event, fn, {
      capture: true,
      passive: true
    });
  });
};

function useAttachEventListeners(elem, events, cb) {
  React.useEffect(() => {
    if (!elem) {
      return;
    }

    setEventListeners(events, cb, elem, "add");
    return () => {
      setEventListeners(events, cb, elem, "remove");
    };
  }, [cb, elem, events]);
}

const GET_POSITION_DEFAULT = e => ({
  top: e.pageY,
  left: e.pageX
});

const HIDE_ON_DEFAULT = "resize contextmenu mousedown click scroll keydown";

const SHOULD_OPEN_DEFAULT = () => true;

function MenuWindow({
  children,
  getPosition = GET_POSITION_DEFAULT,
  hideOn = HIDE_ON_DEFAULT,
  render,
  shouldOpen = SHOULD_OPEN_DEFAULT,
  onOpen,
  onClose,
  viewportOffset = 8
}) {
  const latestEvent = React.useRef(null);
  const [pos, setPos] = React.useState(null);
  const contentRef = React.useRef(null);
  const openWindow = React.useCallback(e => {
    onOpen && onOpen(e);
    setPos(getPosition(e));
  }, [onOpen, setPos, getPosition]);
  const closeWindow = React.useCallback(e => {
    setPos(null);
    onClose && onClose(e);
  }, [setPos, onClose]);
  const handleContextMenu = React.useCallback(e => {
    e.preventDefault();
    e.stopPropagation();
    e.persist();
    latestEvent.current = e;

    if (shouldOpen()) {
      openWindow(e);
    }
  }, [shouldOpen, openWindow]);
  const handleClose = React.useCallback(e => {
    /**
     * Ignore all hideOn events if they're triggered on the content element or any of its children.
     */
    if (!contentRef.current || e.target !== contentRef.current && !contentRef.current.contains(e.target)) {
      closeWindow(e);
    }
  }, [contentRef, closeWindow]);
  useAttachEventListeners(pos ? window : null, hideOn.split(" "), handleClose);
  const renderedContent = latestEvent.current && pos ? render(latestEvent.current, {
    close: () => setPos(null)
  }) : null;
  const {
    style: contentStyles
  } = useFitInViewport(contentRef, pos, viewportOffset);
  return React.createElement(React.Fragment, null, React.cloneElement(React.Children.only(children), {
    onContextMenu: handleContextMenu
  }), renderedContent ? React.createElement(Portal.Portal, null, React.cloneElement(renderedContent, {
    ref: contentRef,
    style: _objectSpread2({}, renderedContent.props.style, {
      position: "absolute"
    }, contentStyles)
  })) : null);
}

exports.MenuWindow = MenuWindow;
