import { useRef, useState, useEffect, useCallback } from 'react';
import { createComponent } from 'reakit-system/createComponent';
import { createHook } from 'reakit-system/createHook';
import { useBox } from '../Box/Box.js';
import { _ as _objectWithoutPropertiesLoose, a as _objectSpread2 } from '../_rollupPluginBabelHelpers-9b9ba5c9.js';
import { mergeRefs } from 'reakit-utils/mergeRefs';
import { isFocusable } from 'reakit-utils/tabbable';
import { hasFocusWithin } from 'reakit-utils/hasFocusWithin';

function isNativeTabbable(element) {
  return element instanceof HTMLButtonElement || element instanceof HTMLInputElement || element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement || element instanceof HTMLAnchorElement || element instanceof HTMLAudioElement || element instanceof HTMLVideoElement;
}

function isInput(element) {
  return element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement;
} // https://twitter.com/diegohaz/status/1176998102139572225


function receivesFocusOnMouseDown(element) {
  var _navigator = navigator,
      userAgent = _navigator.userAgent;

  var is = function is(string) {
    return userAgent.indexOf(string) !== -1;
  };

  var isLikeMac = is("Mac") || is("like Mac");
  var isSafariOrFirefox = is("Safari") || is("Firefox");
  return !isLikeMac || !isSafariOrFirefox || !(element instanceof HTMLButtonElement);
}

var useTabbable = createHook({
  name: "Tabbable",
  compose: useBox,
  keys: ["disabled", "focusable", "unstable_clickOnEnter", "unstable_clickOnSpace"],
  useOptions: function useOptions(_ref, htmlProps) {
    var _ref$unstable_clickOn = _ref.unstable_clickOnEnter,
        unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? true : _ref$unstable_clickOn,
        _ref$unstable_clickOn2 = _ref.unstable_clickOnSpace,
        unstable_clickOnSpace = _ref$unstable_clickOn2 === void 0 ? true : _ref$unstable_clickOn2,
        options = _objectWithoutPropertiesLoose(_ref, ["unstable_clickOnEnter", "unstable_clickOnSpace"]);

    return _objectSpread2({
      disabled: htmlProps.disabled,
      unstable_clickOnEnter: unstable_clickOnEnter,
      unstable_clickOnSpace: unstable_clickOnSpace
    }, options);
  },
  useProps: function useProps(options, _ref2) {
    var htmlRef = _ref2.ref,
        htmlTabIndex = _ref2.tabIndex,
        htmlOnClick = _ref2.onClick,
        htmlOnMouseDown = _ref2.onMouseDown,
        htmlOnKeyDown = _ref2.onKeyDown,
        htmlStyle = _ref2.style,
        htmlProps = _objectWithoutPropertiesLoose(_ref2, ["ref", "tabIndex", "onClick", "onMouseDown", "onKeyDown", "style"]);

    var ref = useRef(null);
    var trulyDisabled = options.disabled && !options.focusable;

    var _React$useState = useState(true),
        nativeTabbable = _React$useState[0],
        setNativeTabbable = _React$useState[1];

    var tabIndex = nativeTabbable ? htmlTabIndex : htmlTabIndex || 0;
    var style = options.disabled && !nativeTabbable ? _objectSpread2({
      pointerEvents: "none"
    }, htmlStyle) : htmlStyle;
    useEffect(function () {
      if (ref.current && !isNativeTabbable(ref.current)) {
        setNativeTabbable(false);
      }
    }, []);
    var onClick = useCallback(function (event) {
      if (options.disabled) {
        event.stopPropagation();
        event.preventDefault();
      } else if (htmlOnClick) {
        htmlOnClick(event);
      }
    }, [options.disabled, htmlOnClick]);
    var onMouseDown = useCallback(function (event) {
      if (options.disabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }

      var self = event.currentTarget;
      var target = event.target;

      if (self.contains(target) && !isInput(target) && !receivesFocusOnMouseDown(self)) {
        event.preventDefault();
        var isFocusControl = isFocusable(target) || target instanceof HTMLLabelElement;

        if (!hasFocusWithin(self) || self === target || !isFocusControl) {
          self.focus();
        }
      }

      if (htmlOnMouseDown) {
        htmlOnMouseDown(event);
      }
    }, [options.disabled, htmlOnMouseDown]);
    var onKeyDown = useCallback(function (event) {
      if (htmlOnKeyDown) {
        htmlOnKeyDown(event);
      }

      if (options.disabled || isNativeTabbable(event.currentTarget)) return; // Per the spec, space only triggers button click on key up.
      // On key down, it triggers the :active state.
      // Since we can't mimic this behavior, we trigger click on key down.

      if (options.unstable_clickOnEnter && event.key === "Enter" || options.unstable_clickOnSpace && event.key === " ") {
        event.preventDefault();
        event.target.dispatchEvent(new MouseEvent("click", {
          view: window,
          bubbles: true,
          cancelable: false
        }));
      }
    }, [options.disabled, options.unstable_clickOnEnter, options.unstable_clickOnSpace, htmlOnKeyDown]);
    return _objectSpread2({
      ref: mergeRefs(ref, htmlRef),
      disabled: trulyDisabled,
      tabIndex: trulyDisabled ? undefined : tabIndex,
      "aria-disabled": options.disabled,
      onClick: onClick,
      onMouseDown: onMouseDown,
      onKeyDown: onKeyDown,
      style: style
    }, htmlProps);
  }
});
var Tabbable = createComponent({
  as: "button",
  useHook: useTabbable
});

export { Tabbable, useTabbable };
